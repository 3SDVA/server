--source include/have_sequence.inc
--source include/not_embedded.inc

# Default settings for all following tests
SET @save_optimizer_switch=@@optimizer_switch;
SET optimizer_trace=1;
SET optimizer_switch='rowid_filter=off';
set optimizer_switch='cost_based_order_by_limit=on';

CREATE TABLE t1(a INT, b INT, c INT, KEY(b), KEY(a));
INSERT INTO t1 SELECT seq, seq, seq from seq_1_to_100;

CREATE TABLE t2(a INT, b INT, key(b));
INSERT INTO t2 SELECT seq, seq from seq_1_to_100;

--echo #
--echo # RUNNING the join cardinality tests when statistics are
--echo # available only from indexes
--echo #

--source include/join_cardinality.inc

DROP TABLE t1,t2;

CREATE TABLE t1(a INT, b INT, c INT);
INSERT INTO t1 SELECT seq, seq, seq from seq_1_to_100;

CREATE TABLE t2(a INT, b INT);
INSERT INTO t2 SELECT seq, seq from seq_1_to_100;

--disable_result_log
--disable_query_log
ANALYZE TABLE t1 PERSISTENT FOR COLUMNS(a,b) INDEXES();
ANALYZE TABLE t2 PERSISTENT FOR ALL;
--enable_query_log
--enable_result_log

--echo #
--echo # RUNNING the join cardinality tests when only statistics
--echo # are available from stat tables
--echo #

--source include/join_cardinality.inc

DROP TABLE t1,t2;


--echo #
--echo # Combination with statistics from stat tables and
--echo # statistics from indexes
--echo #

CREATE TABLE t1(a INT, b INT, c INT, KEY(a));
INSERT INTO t1 SELECT seq, seq, seq from seq_1_to_100;

ANALYZE SELECT * from t1  WHERE t1.b > 3 AND t1.a=t1.b ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

ANALYZE TABLE t1 PERSISTENT FOR COLUMNS (b) INDEXES ();

ANALYZE SELECT * from t1  WHERE t1.b > 3 AND t1.a=10 ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

ANALYZE SELECT * from t1  WHERE t1.b > 3 AND t1.a=t1.b ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

ANALYZE SELECT * from t1  WHERE t1.b > 3 OR t1.a=t1.b ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

DROP TABLE t1;

--echo #
--echo # Tests with simple predicates
--echo #

CREATE TABLE t1(a INT, b INT, c VARCHAR(10), KEY(a), KEY(b));
INSERT INTO t1 SELECT seq, seq, seq from seq_1_to_10;

--echo #
--echo # Tests with LIKE PREDICATES
--echo #

EXPLAIN SELECT * from t1 WHERE t1.a LIKE '%2%' ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;
EXPLAIN SELECT * from t1 WHERE t1.a LIKE '2%' ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

--echo #
--echo # Tests with NULL predicates
--echo #

EXPLAIN SELECT * from t1 WHERE t1.a IS NULL ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

EXPLAIN SELECT * from t1 WHERE t1.a IS NOT NULL ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

--echo #
--echo # Tests with </<=/>/>=/BETWEEN
--echo #

EXPLAIN SELECT * from t1 WHERE t1.a > 5 ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

EXPLAIN SELECT * from t1 WHERE 5 < t1.a ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

EXPLAIN SELECT * from t1 WHERE t1.a >= 10 and t1.b <= 10 ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

EXPLAIN SELECT * from t1 WHERE  t1.a BETWEEN 1 AND 5 ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

EXPLAIN SELECT * from t1 WHERE  5 BETWEEN 1 AND t1.a ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

EXPLAIN SELECT * from t1 WHERE  1 BETWEEN t1.a AND t1.b ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

--echo #
--echo # Tests with IN predicate
--echo #

EXPLAIN SELECT * from t1 WHERE t1.a IN (1,2,3) ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

EXPLAIN SELECT * from t1 WHERE (t1.a,t1.b) IN ((1,1), (2,2), (3,3))
ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

EXPLAIN SELECT * from t1 WHERE
t1.a=t1.b AND (t1.a,t1.b) IN ((1,1), (2,2), (3,3))
ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

EXPLAIN SELECT * from t1
WHERE t1.a=t1.b AND (abs(t1.a),t1.b) IN ((1,1), (2,2), (3,3))
ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

--echo #
--echo # Tests using different functional predicates
--echo #

EXPLAIN SELECT * from t1 WHERE a < 5 XOR a > 10 ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

EXPLAIN SELECT * from t1 WHERE abs(a) > 10 ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

EXPLAIN SELECT * from t1 WHERE a > 10+1 ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

DROP TABLE t1;

--echo #
--echo # Tests when updating stats tables manually
--echo #

CREATE TABLE t1(a INT, b INT);
INSERT INTO t1 SELECT seq, seq from seq_1_to_100;

INSERT INTO
mysql.column_stats(db_name, table_name, column_name, nulls_ratio) VALUES ('test', 't1', 'a', 0);

--echo #
--echo # estimates from stat tables not available, all the fields should be NOT NULL
--echo #

EXPLAIN SELECT * from t1 WHERE a < 10 ORDER BY t1.b LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

DROP TABLE t1;

--echo #
--echo # Using multiple equalities at the top level
--echo #

CREATE TABLE t1(a INT, b INT, c INT);
INSERT INTO t1 SELECT seq, seq, seq from seq_1_to_10;
CREATE TABLE t2(a INT, b INT);
INSERT INTO t2 SELECT seq, seq from seq_1_to_10;

ANALYZE TABLE t1 PERSISTENT FOR ALL;
ANALYZE TABLE t2 PERSISTENT FOR ALL;

EXPLAIN
SELECT * FROM t1,t2 WHERE t1.a= t2.a AND t1.b= t2.b ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

--echo #
--echo # Tests with views (using Item_direct_view_ref)
--echo #

CREATE VIEW v1 AS SELECT a, b  FROM t1;

EXPLAIN SELECT * FROM v1,t1 where v1.b = 10 AND v1.b=t1.b ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

DROP TABLE t1,t2;
DROP VIEW v1;


--echo #
--echo # TESTS to get Number of distinct values(ndv) from rec_per_key
--echo #

CREATE TABLE t1 (a INT, b INT, c INT);
INSERT INTO t1 SELECT seq, seq, seq FROM seq_1_to_10;
ALTER TABLE t1 ADD KEY k1(a);

set @save_use_stat_tables= @@use_stat_tables;
set use_stat_tables='never';
analyze table t1;

CREATE TABLE t2 like t1;
INSERT INTO t2 SELECT * FROM t1;
ANALYZE TABLE t2 PERSISTENT FOR ALL;
EXPLAIN SELECT * FROM t1, t2 where t1.a=t2.a and t2.a<3 ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;
set use_stat_tables=@save_use_stat_tables;

DROP TABLE t1,t2;

--echo #
--echo # Tests with multi-component keys
--echo #

CREATE TABLE t1 (a INT, b INT, c INT, KEY(a,b));
INSERT INTO t1 SELECT seq, seq, seq FROM seq_1_to_10;

EXPLAIN SELECT * FROM t1 where t1.a<3 AND t1.b < 10 ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

ALTER TABLE t1 ADD KEY k1(a);
EXPLAIN SELECT * FROM t1 where t1.a<3 ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

DROP TABLE t1;

--echo #
--echo # Test FOR NOT BETWEEN
--echo #

CREATE TABLE t1(a INT, b VARCHAR(10), c INT, KEY(a));
INSERT INTO t1 SELECT seq, seq, seq from seq_1_to_20;
set optimizer_trace=1;

EXPLAIN
SELECT * FROM t1 WHERE a NOT BETWEEN 3 AND 5 ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

--echo #
--echo # Test FOR NOT IN
--echo #

EXPLAIN
SELECT * FROM t1 WHERE a NOT IN (1,2,3,4,5) ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

--echo #
--echo # Test FOR NOT LIKE
--echo # For this the range optimizer would not give accurate selectivity estimates
--echo #

EXPLAIN
SELECT * FROM t1 WHERE a NOT LIKE '1%' ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

DROP TABLE t1;

CREATE TABLE t1(a INT, b INT, c INT);
INSERT INTO t1 SELECT seq, seq, seq from seq_1_to_10;
set optimizer_trace=1;
SET @save_use_stat_tables= @@use_stat_tables;
SET @save_optimizer_use_condition_selectivity= @@optimizer_use_condition_selectivity;

--echo #
--echo # Test where EITS are available in the stat tables but the query cannot use it
--echo #

ANALYZE TABLE t1 PERSISTENT FOR ALL;

SET use_stat_tables='never';

EXPLAIN SELECT * from t1 WHERE t1.a > 5 ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

--echo #
--echo # Here statistics are available from stat tables and statistics can be used for the query
--echo #

SET use_stat_tables='preferably';
EXPLAIN SELECT * from t1 WHERE t1.a > 5 ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

SET optimizer_use_condition_selectivity=1;

--echo #
--echo # Here statistics are available from stat tables but cannot be used because statistics from
--echo # stat tables are only used when optimizer_use_condition_selectivity > 1
--echo #

EXPLAIN SELECT * from t1 WHERE t1.a > 5 ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

SET @@optimizer_use_condition_selectivity= @save_optimizer_use_condition_selectivity;

SET @@use_stat_tables= @save_use_stat_tables;
SET @@optimizer_use_condition_selectivity= @save_optimizer_use_condition_selectivity;

--echo #
--echo # For predicates like these a=a, it would be good to have the removed but for these currently
--echo # we assume with such predicates we don't have accurate estimates for selectivity
--echo #

EXPLAIN EXTENDED SELECT * FROM t1 WHERE a = a ORDER BY t1.c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

DROP TABLE t1;

--echo #
--echo # Tests where multiple eqaulities have a constant value like a=1 AND a=b
--echo # The muliple equality would be Item_equal(1,a,b), here both having
--echo # statistiscs for the range or ndv is fine
--echo #

CREATE TABLE t1(a INT, b INT, c INT, d INT, KEY(a));
INSERT INTO t1 SELECT seq, seq,seq,seq from seq_1_to_20;

ANALYZE TABLE t1 PERSISTENT FOR ALL;

--echo # DELETING the avg_frequency for column a and b from stat tables
update mysql.column_stats set avg_frequency= NULL
WHERE table_name='t1' AND (column_name='b' OR column_name='a');

EXPLAIN EXTENDED SELECT * FROM t1 WHERE a=1 ORDER BY c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

EXPLAIN EXTENDED SELECT * FROM t1 WHERE a=1 AND a=b ORDER BY c LIMIT 5;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

DROP TABLE t1;

--echo #
--echo # Selectivity estimates will not be accurate here as multiple equality
--echo # is not created when the field involved in the equality are of different
--echo # data types
--echo #

CREATE TABLE t1 (a VARCHAR(10), b INT);
INSERT INTO t1 SELECT seq, seq from seq_1_to_10 ;
CREATE TABLE t2 (a INT, b INT);
INSERT INTO t2 SELECT seq, seq from seq_1_to_10 ;

ANALYZE TABLE t1 PERSISTENT FOR ALL;
ANALYZE TABLE t2 PERSISTENT FOR ALL;

EXPLAIN EXTENDED SELECT * FROM t1,t2 WHERE t1.a= t2.a ORDER BY t1.b LIMIT 10;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

DROP TABLE t1,t2;

--echo #
--echo # Test to check the estimates of join output cardinality
--echo #

CREATE TABLE t1(a int, b int);
INSERT INTO t1 SELECT seq-1, seq-1 from seq_1_to_20;
INSERT INTO t1 SELECT seq-1, seq-1 from seq_1_to_20;
CREATE TABLE t2(a int, b int);
INSERT INTO t2   SELECT seq-1, seq-1 from seq_1_to_10;
INSERT INTO t2   SELECT seq-1, seq-1 from seq_1_to_10;
CREATE TABLE t3(a int, b int);
INSERT INTO t3 SELECT seq-1, seq-1 from seq_1_to_100;
INSERT INTO t3 SELECT seq-1, seq-1 from seq_1_to_100;
ANALYZE TABLE t1 PERSISTENT FOR ALL;
ANALYZE TABLE t2 PERSISTENT FOR ALL;
ANALYZE TABLE t3 PERSISTENT FOR ALL;

let $query=
SELECT * FROM t1,t2
WHERE t1.a = t2.a
ORDER BY t2.b
LIMIT 5;

eval EXPLAIN $query;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_estimate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

let $query=
SELECT * FROM t1,t2,t3
WHERE t1.a = t2.a AND t3.a=t2.a
ORDER BY t2.b
LIMIT 5;

eval EXPLAIN $query;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_estimate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

let $query=
SELECT * FROM t1,t2,t3
WHERE t1.a = t2.a AND t3.b=t2.b
ORDER BY t2.b
LIMIT 5;

eval EXPLAIN $query;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_accurate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;
SELECT JSON_DETAILED(JSON_EXTRACT(trace, '$**.cardinality_estimate'))
FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;

DROP TABLE t1,t2,t3;
