--source include/have_innodb.inc
--source include/have_debug.inc
--source include/have_debug_sync.inc
# need to restart server
--source include/not_embedded.inc

CREATE TABLE t1 (a int not null, b int not null, primary key(a), unique key(b)) engine = innodb;
insert into t1 values (10,10), (20,20), (30,30), (40,40), (50,50), (60,60),
  (70,70), (80,80), (90,90);

connect(con0,localhost,root,,);
start transaction with consistent snapshot;

--connection default
delete from t1 where a between 30 and 80;

--connect(con1, localhost, root)
begin;
insert into t1 values (65,60);

--connection default
SET session innodb_lock_wait_timeout=1;
--error ER_LOCK_WAIT_TIMEOUT
insert into t1 values (45,45);
--error ER_LOCK_WAIT_TIMEOUT
insert into t1 values (75,75);
--exit




--connect(con1, localhost, root)
CREATE TABLE t(a INT PRIMARY KEY) ENGINE=InnoDB;
INSERT INTO t VALUES(1);
BEGIN;
# Generate insert_undo log.
INSERT INTO t VALUES(2);
# Generate update_undo log.
DELETE FROM t WHERE a=2;
--connect(con2, localhost, root)
--echo # Normal MariaDB shutdown would roll back the above transaction.
--echo # We want the transaction to remain open, so we will kill the server
--echo # after ensuring that any non-transactional files are clean.
FLUSH TABLES;
--echo # Create another transaction that will be recovered as COMMITTED.
BEGIN;
# Generate multiple pages of both insert_undo and update_undo, so that
# the state TRX_UNDO_CACHE will not be chosen.
SET session innodb_lock_wait_timeout=1;
let $n= 10000;
while ($n) {
dec $n;
if($n > 8986) {
eval INSERT INTO t VALUES(-$n);
eval DELETE FROM t WHERE a=-$n;
}
if ($n <= 8986)
{
--error ER_LOCK_WAIT_TIMEOUT
eval INSERT INTO t VALUES(-$n);
--exit
}
}
COMMIT;

#connection default;
#--echo # Ensure that the above incomplete transactions become durable.
#SET GLOBAL innodb_flush_log_at_trx_commit=1;
#BEGIN;
#SET session innodb_lock_wait_timeout=1;
#--error ER_LOCK_WAIT_TIMEOUT
#INSERT INTO t VALUES(-10000);

--exit

--source include/have_innodb.inc
--source include/have_debug.inc
--source include/have_debug_sync.inc
--source include/have_sequence.inc

--let $page_size_in_rows = 2
--let $pg_val = ($page_size_in_rows * 10)
--let $pg_gap = ($pg_val*2)
--let $pg_not_gap = ($pg_val*2)
#--let $max_records = 40960
--let $max_records = 1000

SET GLOBAL innodb_purge_rseg_truncate_frequency=1;
create table t1(f1 int unsigned primary key,
               b int unsigned,
               index b (b)) engine=innodb;

--eval insert into t1 select seq*10, seq*10 from seq_1_to_$max_records


#insert into t1 values (10), (20), (30), (40), (50), (60), (70), (80), (90), (100);
# gap                             |                             |

connect(con0,localhost,root,,);
start transaction with consistent snapshot;

connection default;
#delete from t1 where f1 < 100;
--eval delete from t1 where f1 between $pg_not_gap and ($pg_not_gap + $pg_gap)

connect(con1,localhost,root,,);
begin;
--eval select * from t1 where b = ($pg_not_gap + $pg_gap/2) for update
#select * from t1 where f1 = 50 for update;

# connection con0;
# commit;
# --source include/wait_all_purged.inc

connection default;
SET session innodb_lock_wait_timeout=1;
#--error ER_LOCK_WAIT_TIMEOUT
#--eval insert into t1 set f1 = 5;
--error ER_LOCK_WAIT_TIMEOUT
--eval insert into t1 values ($pg_not_gap + $pg_gap - 5, $pg_not_gap + $pg_gap - 5)
#--error ER_LOCK_WAIT_TIMEOUT
#--eval insert into t1 set f1 = ($pg_not_gap + 5)

#--error ER_LOCK_WAIT_TIMEOUT
#insert into t1 set f1 = 45;
#--error ER_LOCK_WAIT_TIMEOUT
#insert into t1 set f1 = 40;

