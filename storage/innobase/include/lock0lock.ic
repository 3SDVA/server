/*****************************************************************************

Copyright (c) 1996, 2015, Oracle and/or its affiliates. All Rights Reserved.
Copyright (c) 2017, 2021, MariaDB Corporation.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA

*****************************************************************************/

/**************************************************//**
@file include/lock0lock.ic
The transaction lock system

Created 5/7/1996 Heikki Tuuri
*******************************************************/

#include "dict0dict.h"
#include "buf0buf.h"
#include "page0page.h"

/*********************************************************************//**
Gets the heap_no of the smallest user record on a page.
@return heap_no of smallest user record, or PAGE_HEAP_NO_SUPREMUM */
UNIV_INLINE
ulint
lock_get_min_heap_no(
/*=================*/
	const buf_block_t*	block)	/*!< in: buffer block */
{
	const page_t*	page	= block->frame;

	if (page_is_comp(page)) {
		return(rec_get_heap_no_new(
			       page
			       + rec_get_next_offs(page + PAGE_NEW_INFIMUM,
						   TRUE)));
	} else {
		return(rec_get_heap_no_old(
			       page
			       + rec_get_next_offs(page + PAGE_OLD_INFIMUM,
						   FALSE)));
	}
}

/*********************************************************************//**
Creates a new record lock and inserts it to the lock queue. Does NOT check
for deadlocks or lock compatibility!
@return created lock */
UNIV_INLINE
lock_t*
lock_rec_create(
/*============*/
	lock_t*			c_lock,	/*!< conflicting lock */
	unsigned		type_mode,/*!< in: lock mode and wait flag */
	const buf_block_t*	block,	/*!< in: buffer block containing
					the record */
	ulint			heap_no,/*!< in: heap number of the record */
	dict_index_t*		index,	/*!< in: index of record */
	trx_t*			trx,	/*!< in,out: transaction */
	bool			caller_owns_trx_mutex)
					/*!< in: TRUE if caller owns
					trx mutex */
{
	btr_assert_not_corrupted(block, index);
	return lock_rec_create_low(
		c_lock,
		type_mode, block->page.id(), block->frame, heap_no,
		index, trx, caller_owns_trx_mutex);
}


struct gap_lock_inherit_functor
{
  gap_lock_inherit_functor(dict_index_t *index) : index(index) {}

  bool operator()(rec_t *rec, buf_block_t *block, bool first_rec) const
  {
    lock_update_delete(block, rec, index, false, false, false);
    return true;
  }
private:
  dict_index_t *index;
};

template <typename Functor>
void for_each_delete_marked(page_cur_t *page_cur, const dict_index_t *index,
                               mtr_t *mtr, const Functor &functor)
{
  rec_t *old_rec= page_cur_get_rec(page_cur);
  buf_block_t *old_block= page_cur_get_block(page_cur);

  rec_t *cur_rec= old_rec;
  buf_block_t *cur_block= old_block;
  bool comp= dict_table_is_comp(index->table);
  bool first_rec= true;
  ulint latch_mode;
  while (functor(cur_rec, cur_block, first_rec))
  {
    first_rec= false;
  get_next_rec:
    if (!page_cur_is_after_last(page_cur))
      page_cur_move_to_next(page_cur);
    else
    {
      uint32_t next_page_no= btr_page_get_next(page_cur_get_page(page_cur));
      if (next_page_no == FIL_NULL)
        break;
      buf_block_t *block= page_cur_get_block(page_cur);
      latch_mode=
          mtr->have_x_latch(page_id_t(block->page.id().space(), next_page_no))
              ? BTR_MODIFY_LEAF
              : BTR_SEARCH_LEAF;
      block= btr_block_get(*index, next_page_no, latch_mode, false, mtr);
      if (cur_block != old_block && latch_mode == BTR_SEARCH_LEAF)
        btr_leaf_page_release(page_cur_get_block(page_cur), latch_mode, mtr);
      page_cur_set_before_first(block, page_cur);
      page_cur_move_to_next(page_cur);
      ut_ad(!page_cur_is_after_last(page_cur));
    }
    cur_rec= page_cur_get_rec(page_cur);
    cur_block= page_cur_get_block(page_cur);
    if (page_rec_is_supremum(cur_rec))
      goto get_next_rec;
    if (!page_rec_is_infimum(cur_rec) && !rec_get_deleted_flag(cur_rec, comp))
      break;
  }
  if (cur_block != old_block)
  {
    ut_ad(latch_mode == BTR_MODIFY_LEAF || latch_mode == BTR_SEARCH_LEAF);
    if (latch_mode == BTR_SEARCH_LEAF)
      btr_leaf_page_release(page_cur_get_block(page_cur), latch_mode, mtr);
    page_cur->block= old_block;
  }
  page_cur->rec= old_rec;
}
